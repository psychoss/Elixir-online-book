# 二进制，字符串和字符列表

在 ”基础类型“ 里，我们学习了字符串，并使用了 `is_binary/1 `函数来检测：

    iex> string = "hello"
    "hello"
    iex> is_binary string
    true
在这章，我们将理解什么是二进制 ，它们怎么与字符串关联，插入在单引号中的值在 Elixir 中的含义。

## UTF-8 和 Unicode

字符串是一种 UTF-8 编码的二进制。为了更好的理解这个意思，我们需要了解字节和代码点的不同：

Unicode 标准给我们所知道的字符都分配了代码点，例如，字母 `a` 的代码点是 `97`，`ł`是 `327`. 当向硬盘写入一个 `hełło`，我们需要把代码点转换成字节。如果我们选择了一个字节代表一个代码点的原则，我们将不能写入 `hełło`，因为`ł`的代码点为322.一个字节只能表示 0-255 的数字。 当然，既然你能在屏幕时上看到 `hełło`，它必然是用某种方式表示了。这就是为什么编码存在的原因。

当我们用字节表示代码点，我们需要用某种方式编码它们。 Elixir 选择 UTF-8 作为主要的和默认的编码。当我们说字符串是一个二进制编码的二进制，意思是字符串是一系列用一定方式组织，描述指定的代码点的字节集合，就像 UTF-8 编码规范指定的一样。

因为我们有一个代码点为 `332` 的 `ł` 字符，我们需要超过一个字节来描述它。这就是`byte_size/1`和`String.length/1` 函数计算结果不同的原因：

    iex> string = "hełło"
    "hełło"
    iex> byte_size string
    7
    iex> String.length string
    5
>注意：如果你运行的系统是 Windows，你的终端使用的可能不是 UTF-8 编码。你可以在进入 IEx 之前使用 `chcp 65001` 改变你当前的会话的编码。

 UTF-8 需要用 `1` 个字节来描述字节码 `h`，`e` 和 `o`，需要 `2` 个字节来描述 ` ł`。在 Elixir 中，你可以使用 `?` 来获取字节码：

    iex> ?a
    97
    iex> ?ł
    322
你也可以使用 String 模块的函数把字符串分割成字节码：

    iex> String.codepoints("hełło")
    ["h", "e", "ł", "ł", "o"]
你将看到 Elixir 提供很强大的处理字符的工具。它也支持很多 Uncicode 操作。  Elixir 通过了这篇文章[The string type is broken](http://mortoray.com/2013/11/27/the-string-type-is-broken/) 提到的所有测试。

但是，这只是字符串的一部分。如果一个字符串是二进制， 我们已经用 `is_binary/1` 测试了。 Elixir 必然有一个底层的类型让字符串变得更强大。这是事实，让我们说说二进制！

## 二进制 (和比特字符串)

在 Elixir 中， 你可以使用 `<<>>` 定义一个二进制：

    iex> <<0, 1, 2, 3>>
    <<0, 1, 2, 3>>
    iex> byte_size <<0, 1, 2, 3>>
    4
一个二进制其实就是一系列的字节。当然，这些字节可以任何方式组织，甚至组成一个并不表示合法字符串的序列：

    iex> String.valid?(<<239, 191, 191>>)
    false
字符串连接符其实是一个二进制连接符：

    iex> <<0, 1>> <> <<2, 3>>
    <<0, 1, 2, 3>>
一个在 Elixir 经常用到技巧是连接一个 `null` 字节到一个字符串，来查看其内部的二进制：

    iex> "hełło" <> <<0>>
    <<104, 101, 197, 130, 197, 130, 111, 0>>
二进制当中的每一个数字表示一个字节，而且必须小于或等于 255。二进制允许使用修饰符来保存大于 255 的数字，或者把一个字节码转换成  UTF-8 的表示方式：

    iex> <<255>>
    <<255>>
    iex> <<256>> # truncated
    <<0>>
    iex> <<256 :: size(16)>> # use 16 bits (2 bytes) to store the number
    <<1, 0>>
    iex> <<256 :: utf8>> # the number is a code point
    "Ā"
    iex> <<256 :: utf8, 0>>
    <<196, 128, 0>>
如果一个字节有 8 比特，如果传入 1 比特会发生什么？

    iex> <<1 :: size(1)>>
    <<1::size(1)>>
    iex> <<2 :: size(1)>> # truncated
    <<0::size(1)>>
    iex> is_binary(<< 1 :: size(1)>>)
    false
    iex> is_bitstring(<< 1 :: size(1)>>)
    true
    iex> bit_size(<< 1 :: size(1)>>)
    1
值不再是二进制，而是一个比特字符串——也就是一系列比特！所以一个二进制是一个包含值除以8个比特的比特字符串！

我们也可以在 二进制/比特字符串上使用模式匹配：

    iex> <<0, 1, x>> = <<0, 1, 2>>
    <<0, 1, 2>>
    iex> x
    2
    iex> <<0, 1, x>> = <<0, 1, 2, 3>>
    ** (MatchError) no match of right hand side value: <<0, 1, 2, 3>>
注意，虽然二进制中的每一个实体被想成都是精确的 8 比特。但是，我们可以使用 `binary` 修饰符匹配其他的：

    iex> <<0, 1, x :: binary>> = <<0, 1, 2, 3>>
    <<0, 1, 2, 3>>
    iex> x
    <<2, 3>>
上面的模式仅在 `binary` 在 `<<>>` 的结尾时才会有效。同样的结果可以字符连接符 ` <>` 做到：

    iex> "he" <> rest = "hello"
    "hello"
    iex> rest
    "llo"
关于比特字符串，二进制和字符串。一个字符串是一个 UTF-8 编码的二进制，而一个二进制是一个包含值除 0 个比特的比特字符串。虽然在这里展示了 Elixir 灵活操作比特和字节的各种方式，绝大多数情况下关于二进制的处理，你只需要使用 `is_binary/1 ` 和 `byte_size/1` 函数。

## 字符列表

字符列表其实就一系列字符的集合：

    iex> 'hełło'
    [104, 101, 322, 322, 111]
    iex> is_list 'hełło'
    true
    iex> 'hello'
    'hello'
你可以看到，它并不包含字节，一个字符列表包括的是一系列插入在单引号中的字节码（注意，IEx 不会任何超出 ASCII 范围的字节码）。所以说，单引号表示字节列表，双引号表示字符串。

在实战中，字节列表通常在与 Erlang 交互的时候使用，特别是那些历史比较悠久，不接受二进制为参数的类库。你可以使用函数 `to_string/1` 和 `to_char_list/1` 在字符串和字节列表之间转换：

    iex> to_char_list "hełło"
    [104, 101, 322, 322, 111]
    iex> to_string 'hełło'
    "hełło"
    iex> to_string :hello
    "hello"
    iex> to_string 1
    "1"
注意这些函数是多态的。它不仅能把字节列表转换成字符串，也能把数字，原子和其他类型转换成字符串。
